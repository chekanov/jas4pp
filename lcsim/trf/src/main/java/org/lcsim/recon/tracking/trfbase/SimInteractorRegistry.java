package org.lcsim.recon.tracking.trfbase;
 
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.Iterator;
import org.lcsim.recon.tracking.trfutil.Assert;

/**Class used to add an interaction to the tracks internally 
* generated by gtr.  The tracks can be defined at any surface.
 *
* @author Norman A. Graf
* @version 1.0
 */

public class SimInteractorRegistry extends SimInteractor {

	// map of SimInteractors keyed by Surface
	private Map _imap;
 
	// 

	/**
	 *default Constructor
	 *
	 */
	public SimInteractorRegistry()
	{
		_imap = new HashMap();
	}

	// 

	/**
	 *copy Constructor
	 *
	 * @param   reg   SimInteractorRegistry to replicate
	 */
	public SimInteractorRegistry(SimInteractorRegistry reg)
	{
throw new IllegalArgumentException("Not yet implemented!");
	}

	// 

	/**
	 *associate this surface with some kind of interaction
	 *
	 * @param   srf   Surface at which to establish this SimInteractorRegistry
	 * @param   simint  SimInteractor to associate with this surface
	 */
	public void registerInteractor( Surface srf, SimInteractor simint)
	{
		if(_imap.containsKey(srf)) throw new IllegalArgumentException("This surface already has a SimInteractor associated with it");
		_imap.put( srf, simint );
	}

	// 

	/**
	 *modify VTrack with the appropriate interaction
	 *
	 * @param   vtrk  VTrack to interact
	 */
	public void interact( VTrack vtrk)
	{
		Surface thisSurf = vtrk.surface();
		// cng why???
		// The surface must have some kind of interactor registered,
		// even if it is a null pointer, meaning no interaction.
		boolean found = _imap.containsKey(thisSurf);
		//cng why?  if(!found) throw new IllegalArgumentException("No SimInteractor defined for this surface!");
		if(!found) return;
		SimInteractor simint = (SimInteractor) _imap.get(thisSurf);
		simint.interact( vtrk );
	}

	// 

	/**
	 *return the bounded surface of the VTrack.  This is needed because
	* VTracks typically have pure surfaces
	 *
	 * @param   vtrk  VTrack for which to get the bounded surface
	 * @return  bounded Surface 
	 */
	public Surface bsurf( VTrack vtrk)
	{
		Surface thisSurf = vtrk.surface();
		boolean found = false;
		//  pair< SurfacePtr, SimInteractorPtr > srf_inter;
		//  interMap::iterator mapIter;
		Set keys = _imap.keySet();
		for( Iterator it = keys.iterator(); it.hasNext(); )
		{
			Surface surf = (Surface) it.next();
			if( surf.pureEqual(thisSurf) )
			{
				if(surf.status(vtrk).inBounds())
				{
					found = true;
					return surf;
				}
			}
		}
		Assert.assertTrue(found);
		return thisSurf;  
	}

	// 

	/**
	 *Copy
	 *
	 * @return new copy of this SimInteractorRegistry    
	 */
	public SimInteractor newCopy()
	{ 
	  return new SimInteractorRegistry(this); 
	}

	// output stream

	/**
	 * String representation of the SimInteractorRegistry
	 *
	 * @return  String representation of the SimInteractorRegistry   
	 */
	public String toString()
	{
	String className = getClass().getName();
	int lastDot = className.lastIndexOf('.');
	if(lastDot!=-1)className = className.substring(lastDot+1);
	
		StringBuffer sb = new StringBuffer(className+"\n");
		sb.append(_imap);
		return sb.toString();
	}
}